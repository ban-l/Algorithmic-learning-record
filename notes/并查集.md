# 并查集

- 并查集（不交集数据结构）是一种数据结构
- 用于处理一些**不交集**（Disjoint     sets，一系列没有重复元素的集合）的**合并及查询**问题
- 并查集支持如下操作：
  - **查询**：**查询某个元素属于哪个集合**，通常是返回集合内的一个“**代表元素**”。用于判断两个元素是否在同一个集合之中。
  - **合并**：将把两个不相交的集合合并为一个集合。
  - 添加：添加一个新集合，其中有一个新元素。添加操作不如查询和合并操作重要，常常被忽略。
- 并查集特指其中最常见的一种实现：**不交集森林**（Disjoint-set     forest）
- **作用**：
  - **求连通分量数**
    - 如果一个**图**中所有点都存在可达关系（直接或间接相连），则此图的连通分支数为1；
    - 如果此图有**两大子图**各自全部可达，则此图的连通分支数为2……
  - 维护无向图的连通性（判断两个点是否在同一连通块内，或增加一条边后是否会产生环）；
  - 用在求解最小生成树的Kruskal算法里。



## 初始化

- 用一个数组 **fa[]** 来存储每个元素的**父节点**，一开始，每个元素的**父节点设为自己**

 

## find()函数的定义与实现

- **查询**
- 对于某个点x，查询属于哪个集合，返回其所属集合的**代表元**，以此判断两个元素是否在一个集合内
- 一层一层访问父节点，直至**根节点**（父节点是本身）(**代表元**)

 

## join()函数的定义与实现

- **合并**
- 合并两个不相交的集合
- 先找到两个集合的代表元，然后将前者的父节点设为后者，当然也可以将后者的父节点设为前者，都可。

 

## 路径压缩算法一（优化find()函数）

- 把沿途的每个节点的**父节点**都**设为根节点，**降低树的高度
- 第一次查询没有压缩效果，之后才有效

 

##  路径压缩算法二（按秩合并）

- 使用数组**rank[]**，记录每个**根节点**对应的树的**深度**（不是根节点，rank为子树深度）
- **初始rank设为1**，合并时，(rank)**秩**较小者往较大者合并
- 如果rank[x]<rank[y],     fa[x]=y
- 如果rank[x]==rank[y],     任意指定父节点
- 如果rank[x]>rank[y],     x=fa[y]